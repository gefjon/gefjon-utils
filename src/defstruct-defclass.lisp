(in-package :gefjon-utils)

(compiler-defun accessor-name (class-name slot-name)
  (symbol-concatenate class-name '- slot-name))

(defmacro err-uninit ()
  '(error "required field uninit"))

(compiler-defun accessor-type-declamation (class-name slot-descriptor)
  `(ftype (function (,class-name) ,(slot-descriptor-type slot-descriptor))
          ,(accessor-name class-name (slot-descriptor-name slot-descriptor))))

(compiler-state
  (cl:defstruct (slot-descriptor (:type list))
    (name (err-uninit) :type symbol)
    (type (err-uninit))))

(compiler-defun slot-descriptor-init-unbound-p (slot-descriptor)
  (destructuring-bind (name type &key init-unbound &allow-other-keys) slot-descriptor
    (declare (ignore name type))
    (when init-unbound t)))

(compiler-defun slot-descriptor-initform (slot-descriptor)
  (destructuring-bind (name type &key (initform nil supplied-p) &allow-other-keys) slot-descriptor
    (declare (ignore name type))
    (values initform supplied-p)))

(compiler-defun slot-descriptors-types (slot-descriptors)
  (mapcar #'slot-descriptor-type slot-descriptors))

(compiler-defun slot-descriptors-names (slot-descriptors)
  (mapcar #'slot-descriptor-name slot-descriptors))

(compiler-defun struct-slot (slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFSTRUCT'"
  `(,(slot-descriptor-name slot-descriptor)
     (err-uninit)
     :type ,(slot-descriptor-type slot-descriptor)))

(compiler-defun struct-slots (slot-descriptors)
  (iter (for slot in slot-descriptors)
        (collecting (struct-slot slot))))

(compiler-defun class-slot (class-name slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFCLASS'"
  (destructuring-bind (slot-name slot-type &key may-init-unbound
                                             (initform '(err-uninit) initform-supplied-p)
                                             (initarg (make-keyword slot-name))
                                             (accessor (accessor-name class-name slot-name))
                                             read-only)
      slot-descriptor
    (when (and may-init-unbound initform-supplied-p)
      (error "initform is incompatible with uninit in class slot"))
    `(,slot-name
      :type ,slot-type
      ,@(unless may-init-unbound
          `(:initform ,initform))
      ,@(when initarg
          `(:initarg ,initarg))
      ,@(when accessor
          `(,(if read-only :reader :accessor) ,accessor)))))

(compiler-defun class-slots (class-name slot-descriptors)
  (iter (for slot in slot-descriptors)
        (collecting (class-slot class-name slot))))

(compiler-defun slot-initializer-arg (slot-name)
  `(,(make-keyword slot-name) ,slot-name))

(compiler-defun slot-initializers (slot-names)
  (alexandria:mappend #'slot-initializer-arg
                      slot-names))

(compiler-defun constructor-name (class-name)
  (symbol-concatenate 'make- class-name))

(defmacro define-boa-constructor-for-class (class-name slots)
  "generate a BOA constructor from a class name and a list of slot names

CLASS-NAME should be a symbol which names a class
SLOTS should be a list of symbols which name slots of that class

BOA stands for By Order of Arguments, as opposed to a keyword
constructor like `MAKE-INSTANCE'."
  `(defun ,(constructor-name class-name) ,slots
     (make-instance ',class-name
                    ,@(slot-initializers slots))))

(defmacro slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (alexandria:symbolicate class-name '- slot-name '-boundp))
           (defboundp (slot-name)
             `(progn
                (declaim (ftype (function (,class-name) boolean)
                                ,(boundp-name slot-name)))
                (defun ,(boundp-name slot-name) (instance)
                  (slot-boundp instance ',slot-name)))))
    `(progn ,@(mapcar #'defboundp (slot-descriptors-names slot-descriptors)))))

(defmacro defclass (class-name slot-descriptors &key (documentation "generated by `GEFJON-UTILS:DEFCLASS'")
                                                  superclasses)
  "an altpernate syntax for `CL:DEFCLASS'.

each SLOT-DESCRIPTOR should be a list of the form
 (SLOT-NAME SLOT-TYPE &key MAY-INIT-UNBOUND INITFORM INITARG ACCESSOR)

the new class will have a slot named SLOT-NAME with a declared type of
SLOT-TYPE.

if MAY-INIT-UNBOUND is supplied and non-nil, the slot will be
uninitialized until/unless set either by passing INITARG to
`MAKE-INSTANCE' or using (`SETF' ACCESSOR).

if INITFORM is supplied, its value will be the slot's default
initform, unless overridden by passing INITARG to
`MAKE-INSTANCE'. INITFORM and MAY-INIT-UNBOUUND are incompatible.

INITARG should be a keyword. it defaults to the name of the slot
converted to a keyword. if INITARG is supplied and NIL, there will be
way to initialize the slot while calling `MAKE-INSTANCE'.

ACCESSOR should be a symbol. it defaults to a symbol that looks like
CLASS-NAME-SLOT-NAME interned in `*PACKAGE*'. if supplied and NIL, no
accessor will be defined."
  `(progn
     (cl:defclass ,class-name ,superclasses
       ,(class-slots class-name slot-descriptors)
       (:documentation ,documentation))
     (slot-boundp-forms ,class-name
                        ,(remove-if-not #'slot-descriptor-init-unbound-p slot-descriptors))))

(compiler-defun defstruct-boa-constructor (struct-name slot-descriptors)
  `(:constructor ,(constructor-name struct-name)
                 ,(slot-descriptors-names slot-descriptors)))

(defmacro declaim-accessor-types (struct-name slot-descriptors)
  (flet ((slot-accessor-declamation (slot)
           (accessor-type-declamation struct-name slot)))
    `(declaim ,@(mapcar #'slot-accessor-declamation slot-descriptors))))

(defmacro defstruct (struct-name slot-descriptors &key (documentation "generated by `GEFJON-UTILS:DEFSTRUCT'")
                                                    repr-type)
  (let ((options (remove nil `(,(defstruct-boa-constructor struct-name slot-descriptors)
                                ,(when repr-type `(:type ,repr-type))
                                ;; passing :NAMED is a no-op (i.e. safe) when not using an explicit :TYPE
                                :named))))
    `(progn
       ,(when repr-type
          ;; if we're passing a :TYPE to CL:DEFSTRUCT, then we have to
          ;; generate our own DEFTYPE form
          `(deftype ,struct-name ()
             '(and ,repr-type (satisfies ,(symbol-concatenate struct-name '-p)))))
       (declaim-accessor-types ,struct-name ,slot-descriptors)

       (cl:defstruct (,struct-name ,@options)
         ,documentation
         ,@(struct-slots slot-descriptors)))))

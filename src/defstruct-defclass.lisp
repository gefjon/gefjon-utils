(in-package :gefjon-utils)

(compiler-defun accessor-name (class-name slot-name)
  (symbol-concatenate class-name '- slot-name))

(defmacro err-uninit ()
  '(error "required field uninit"))

(compiler-defun accessor-type-declamation (class-name slot-descriptor)
  `(ftype (function (,class-name) ,(slot-descriptor-type slot-descriptor))
          ,(accessor-name class-name (slot-descriptor-name slot-descriptor))))

(compiler-state
  (cl:defstruct (slot-descriptor (:type list))
    (name (err-uninit) :type symbol)
    (type (err-uninit))))

(compiler-defun slot-descriptor-init-unbound-p (slot-descriptor)
  (destructuring-bind (name type &key init-unbound) slot-descriptor
    (declare (ignore name type))
    (when init-unbound t)))

(compiler-defun slot-descriptors-types (slot-descriptors)
  (mapcar #'slot-descriptor-type slot-descriptors))

(compiler-defun slot-descriptors-names (slot-descriptors)
  (mapcar #'slot-descriptor-name slot-descriptors))

(compiler-defun struct-slot (slot-descriptor)
  `(,(slot-descriptor-name slot-descriptor)
     (err-uninit)
     :type ,(slot-descriptor-type slot-descriptor)))

(compiler-defun struct-slots (slot-descriptors)
  (iter (for slot in slot-descriptors)
        (collecting (struct-slot slot))))

(compiler-defun class-slot (class-name slot-descriptor)
  (destructuring-bind (slot-name slot-type &key init-unbound) slot-descriptor
    `(,slot-name
      ,@(unless init-unbound
          `(:initform (err-uninit)
            :initarg ,(make-keyword slot-name)))
       :type ,slot-type
       :accessor ,(accessor-name class-name slot-name))))

(compiler-defun class-slots (class-name slot-descriptors)
  (iter (for slot in slot-descriptors)
        (collecting (class-slot class-name slot))))

(compiler-defun slot-initializer-arg (slot-name)
  `(,(make-keyword slot-name) ,slot-name))

(compiler-defun slot-initializers (slot-names)
  (alexandria:mappend #'slot-initializer-arg
                      slot-names))

(compiler-defun constructor-name (class-name)
  (symbol-concatenate 'make- class-name))

(defmacro defclass-boa-constructor (class-name slot-descriptors)
  (let* ((always-bound-slots (remove-if #'slot-descriptor-init-unbound-p slot-descriptors))
         (constructor-arglist (slot-descriptors-names always-bound-slots))
         (type-arglist (slot-descriptors-types always-bound-slots))
         (constructor-name (constructor-name class-name)))
    `(progn
       (declaim (ftype (function ,type-arglist ,class-name)
                       ,constructor-name))
       (defun ,constructor-name ,constructor-arglist
         (make-instance ',class-name
                        ,@(slot-initializers constructor-arglist))))))

(defmacro slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (alexandria:symbolicate class-name '- slot-name '-boundp))
           (defboundp (slot-name)
             `(progn
                (declaim (ftype (function (,class-name) boolean)
                                ,(boundp-name slot-name)))
                (defun ,(boundp-name slot-name) (instance)
                  (slot-boundp instance ',slot-name)))))
    `(progn ,@(mapcar #'defboundp (slot-descriptors-names slot-descriptors)))))

(defmacro defclass (class-name slot-descriptors &key (documentation "generated by STATIC-TYPES:DEFCLASS")
                                                  superclasses)
  "an alternate syntax for `cl:defclass'"
  `(progn
     (cl:defclass ,class-name ,superclasses
       ,(class-slots class-name slot-descriptors)
       (:documentation ,documentation))
     (slot-boundp-forms ,class-name
                        ,(remove-if-not #'slot-descriptor-init-unbound-p slot-descriptors))
     (defclass-boa-constructor ,class-name ,slot-descriptors)))

(compiler-defun defstruct-boa-constructor (struct-name slot-descriptors)
  `(:constructor ,(constructor-name struct-name)
                 ,(slot-descriptors-names slot-descriptors)))

(defmacro declaim-accessor-types (struct-name slot-descriptors)
  (flet ((slot-accessor-declamation (slot)
           (accessor-type-declamation struct-name slot)))
    `(declaim ,@(mapcar #'slot-accessor-declamation slot-descriptors))))

(defmacro defstruct (struct-name slot-descriptors &key (documentation "generated by STATIC-TYPES:DEFSTRUCT")
                                                    repr-type)
  (let ((options (remove nil `(,(defstruct-boa-constructor struct-name slot-descriptors)
                                ,(when repr-type `(:type ,repr-type))
                                ;; passing :NAMED is a no-op (i.e. safe) when not using an explicit :TYPE
                                :named))))
    `(progn
       ,(when repr-type
          ;; if we're passing a :TYPE to CL:DEFSTRUCT, then we have to
          ;; generate our own DEFTYPE form
          `(deftype ,struct-name ()
             '(and ,repr-type (satisfies ,(symbol-concatenate struct-name '-p)))))
       (declaim-accessor-types ,struct-name ,slot-descriptors)

       (cl:defstruct (,struct-name ,@options)
         ,documentation
         ,@(struct-slots slot-descriptors)))))

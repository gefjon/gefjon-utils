(uiop:define-package :gefjon-utils/defclass
    (:mix :cl)
  (:import-from :alexandria
   :mappend :symbolicate :curry)
  (:import-from :gefjon-utils/clos
   :print-all-slots-mixin)
  (:import-from :gefjon-utils/symbol-manipulations
   :make-keyword :symbol-concatenate)
  (:import-from :gefjon-utils/type-definitions
   :optional)
  (:shadow :defclass)
  (:export :defclass))
(cl:in-package :gefjon-utils/defclass)

(defun accessor-name (class-name slot-name)
  (symbol-concatenate class-name '- slot-name))

(defmacro err-uninit (slot-name)
  `(error "required field uninit: ~s" ',slot-name))

(defstruct slot-descriptor
  (name (err-uninit name) :type symbol)
  (type (err-uninit type))
  (may-init-unbound nil :type boolean)
  (initform (err-uninit initform))
  (initarg (err-uninit initarg) :type (optional keyword))
  (accessor (err-uninit accessor) :type symbol)
  (read-only nil :type boolean))

(defun parse-slot-descriptor (class-name list)
  (destructuring-bind (name type &key may-init-unbound
                                   (initform `(err-uninit ,name) initform-supplied-p)
                                   (initarg (make-keyword name))
                                   (accessor (accessor-name class-name name))
                                   read-only)
      list
    (when (and may-init-unbound initform-supplied-p)
      (error "initform and may-init-unbound are mutually exclusive"))
    (when (and read-only (not accessor))
      (error ":READ-ONLY T is incompatible with :ACCESSOR NIL"))
    (make-slot-descriptor :name name
                            :type type
                            :may-init-unbound may-init-unbound
                            :initform initform
                            :initarg initarg
                            :accessor accessor
                            :read-only read-only)))

(defun output-slot-descriptor (slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFCLASS'"
  (with-slots (name type may-init-unbound initform initarg accessor read-only) slot-descriptor
    `(,name
      :type ,type
      ,@(unless may-init-unbound
          `(:initform ,initform))
      ,@(when initarg
          `(:initarg ,initarg))
      ,@(when accessor
          `(,(if read-only :reader :accessor) ,accessor)))))

(defun slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (symbolicate class-name '- slot-name '-boundp))
           (defboundp (slot-descriptor)
             (with-slots (name) slot-descriptor
               `(progn
                  (declaim (ftype (function (,class-name) boolean)
                                  ,(boundp-name name)))
                  (defun ,(boundp-name name) (instance)
                    (slot-boundp instance ',name))))))
    `(progn ,@(mapcar #'defboundp
                      (remove-if-not #'slot-descriptor-may-init-unbound slot-descriptors)))))

(defmacro defclass (class-name slot-descriptors &key (documentation "generated by `GEFJON-UTILS:DEFCLASS'")
                                                  superclasses)
  "an altpernate syntax for `CL:DEFCLASS'.

arranges for a `PRINT-OBJECT' method which prints all the present
slots of the instance, including inherited slots.

each SLOT-DESCRIPTOR should be a list of the form
 (SLOT-NAME SLOT-TYPE &key MAY-INIT-UNBOUND INITFORM INITARG ACCESSOR
READ-ONLY). the new class will have a slot named SLOT-NAME with a
declared type of SLOT-TYPE.

if MAY-INIT-UNBOUND is `T', the slot will be
uninitialized until/unless set either by passing INITARG to
`MAKE-INSTANCE' or using (`SETF' ACCESSOR).

if INITFORM is supplied, its value will be the slot's default
initform, unless overridden by passing INITARG to
`MAKE-INSTANCE'. INITFORM and MAY-INIT-UNBOUUND are incompatible.

INITARG should be a keyword or `NIL'. it defaults to the name of the slot
converted to a keyword. if INITARG is supplied and NIL, there will be
no way to initialize the slot while calling `MAKE-INSTANCE'.

ACCESSOR should be a symbol. it defaults to a symbol that looks like
CLASS-NAME-SLOT-NAME interned in `*PACKAGE*'. if supplied and NIL, no
accessor will be defined.

if READ-ONLY is `T', a reader will be defined instead of an
accessor. the slot will still be writable with (`SETF'
`SLOT-VALUE'). READ-ONLY is incompatible with `:ACCESSOR' `NIL'"
  (let ((slot-descriptors (mapcar (curry #'parse-slot-descriptor class-name) slot-descriptors))
        (superclasses (append superclasses '(print-all-slots-mixin))))
    `(progn
       (cl:defclass ,class-name ,superclasses
         ,(mapcar #'output-slot-descriptor slot-descriptors)
         (:documentation ,documentation))
       ,(slot-boundp-forms class-name
                           slot-descriptors))))

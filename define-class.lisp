(uiop:define-package #:gefjon-utils/define-class
  (:mix #:cl #:iterate)
  (:import-from #:alexandria
                #:symbolicate #:remove-from-plist)
  (:import-from #:gefjon-utils/clos
                #:print-all-slots-mixin #:print-all-slots-condition)
  (:import-from #:gefjon-utils/symbol-manipulations
                #:make-keyword)
  (:import-from #:gefjon-utils/type-definitions
                #:optional)
  (:export #:define-class #:define-enum #:slots-list-to-make-instance-args))
(in-package #:gefjon-utils/define-class)

(defmacro err-uninit (slot-name)
  `(error "required field uninit: ~s" ',slot-name))

(defstruct slot-descriptor
  (public-name (err-uninit public-name) :type symbol)
  (private-name (err-uninit private-name) :type symbol)
  (type (err-uninit type))
  (initform (err-uninit initform))
  (has-initform-p nil :type boolean)
  (initarg (err-uninit initarg) :type (optional keyword))
  (accessor (err-uninit accessor) :type symbol)
  (read-only nil :type boolean)
  (documentation nil :type (or null string))
  (allocation :instance :type (member :class :instance)))

(defun parse-slot-descriptor (list)
  (destructuring-bind (public-name type &key (may-init-unbound t)
                                          (private-name (symbolicate "%" public-name))
                                          (initform `(err-uninit ,public-name) initform-supplied-p)
                                          (initarg (make-keyword public-name))
                                          (accessor public-name)
                                          read-only
                                          documentation
                                          (allocation :instance))
      list
    (when (and read-only (not accessor))
      (error ":READ-ONLY T is incompatible with :ACCESSOR NIL"))
    (make-slot-descriptor :public-name public-name
                          :private-name private-name
                          :type type
                          :initform initform
                          :has-initform-p (or initform-supplied-p (not may-init-unbound))
                          :initarg initarg
                          :accessor accessor
                          :read-only read-only
                          :documentation documentation
                          :allocation allocation)))

(defun output-slot-descriptor (slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFCLASS'"
  (with-slots (private-name type has-initform-p initform initarg accessor read-only documentation allocation)
      slot-descriptor
    `(,private-name
      :type ,type
      ,@(when has-initform-p
          `(:initform ,initform))
      ,@(when initarg
          `(:initarg ,initarg))
      ,@(when accessor
          `(,(if read-only :reader :accessor) ,accessor))
      ,@(when documentation
          `(:documentation ,documentation))
      :allocation ,allocation)))

(defun slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (symbolicate slot-name '-boundp))
           (defboundp (slot-descriptor)
             (with-slots (public-name private-name) slot-descriptor
               `(defmethod ,(boundp-name public-name) ((instance ,class-name))
                  (slot-boundp instance ',private-name)))))
    `(progn ,@(mapcar #'defboundp
                      slot-descriptors))))

(defmacro define-class (class-name slot-descriptors
                        &key (documentation "generated by `GEFJON-UTILS:DEFINE-CLASS'")
                          superclasses
                          condition)
  "an altpernate syntax for `cl:defclass' and `cl:define-condition'.

arranges for a `print-object' method which prints all the present
slots of the instance, including inherited slots.

each SLOT-DESCRIPTOR should be a list of the form
 (SLOT-NAME SLOT-TYPE &key MAY-INIT-UNBOUND INITFORM INITARG ACCESSOR
READ-ONLY). the new class will have a slot named SLOT-NAME with a
declared type of SLOT-TYPE.

if MAY-INIT-UNBOUND is true, the slot will be
uninitialized until/unless set either by passing INITARG to
`make-instance' or using (`setf' ACCESSOR).

if INITFORM is supplied, its value will be the slot's default
initform, unless overridden by passing INITARG to
`make-instance'. INITFORM and MAY-INIT-UNBOUUND are incompatible.

INITARG should be a keyword or nil. it defaults to the name of the slot
converted to a keyword. if INITARG is supplied and NIL, there will be
no way to initialize the slot while calling `make-instance'.

ACCESSOR should be a symbol. it defaults to a symbol that looks like
CLASS-NAME-SLOT-NAME interned in `*package*'. if supplied and NIL, no
accessor will be defined.

if READ-ONLY is true, a reader will be defined instead of an
accessor. the slot will still be writable with (`setf'
`slot-value'). READ-ONLY is incompatible with `:accessor' `nil'

If CONDITION is true, the new class will be defined as a condition,
rather than as a normal class."
  (let ((slot-descriptors (mapcar #'parse-slot-descriptor slot-descriptors))
        (superclasses (append superclasses (if condition '(print-all-slots-condition)
                                               '(print-all-slots-mixin))))
        (defclass (if condition 'define-condition 'defclass)))
    `(progn
       (,defclass ,class-name ,superclasses
         ,(mapcar #'output-slot-descriptor slot-descriptors)
         (:documentation ,documentation))
       ,(slot-boundp-forms class-name
                           slot-descriptors))))

(defmacro define-enum (type-name common-slots variants &rest define-class-options)
  "define an enum or sum type named TYPE-NAME with COMMON-SLOTS.

this compiles into a superclass TYPE-NAME and a subtype for each of
the VARIANTS. it's likely incorrect to do (`MAKE-INSTANCE'
'TYPE-NAME), since TYPE-NAME is intended to be an abstract
superclass.

VARIANTS should be a list of variant-descriptors, each of which is a
list of the form (VARIANT-NAME UNIQUE-SLOTS).

UNIQUE-SLOTS is a list of slot-descriptors, each of which is a list of
the form (SLOT-NAME SLOT-TYPE `&KEY' INITFORM MAY-INIT-UNBOUND
ACCESSOR). the `&KEY' args all have sensible defaults."
  `(progn (define-class ,type-name ,common-slots ,@define-class-options)
          (extend-enum ,type-name ,variants)))

(defmacro extend-enum (enum-name variants)
  "add additional VARIANTS to an already-defined enum ENUM-NAME.

this just defines subclasses of ENUM-NAME."
  (flet ((define-variant (variant)
           (destructuring-bind (variant-name unique-slots
                                &rest options &key superclasses &allow-other-keys)
               variant
             `(define-class ,variant-name
                ,unique-slots
                ;; put declared superclasses before the enum class, to
                ;; allow mixins on variants which supersede methods
                ;; from the enum class.
                :superclasses (,@superclasses ,enum-name)
                ,@(remove-from-plist options :superclasses)))))
    `(progn
       ,@(mapcar #'define-variant variants))))

(defun slots-list-to-make-instance-args (slots)
  "For a list of slot descriptors like ((A TYPE-A) (B TYPE-B)), return a list (:A A :B B) which can be inserted into a `make-instance' form"
  (iter (for (slot-name) in slots)
    (collect (make-keyword slot-name))
    (collect slot-name)))

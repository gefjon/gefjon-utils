(uiop:define-package gefjon-utils/define-class
  (:mix cl iterate)
  (:import-from alexandria
                symbolicate remove-from-plist)
  (:import-from gefjon-utils/clos
                print-all-slots-mixin)
  (:import-from gefjon-utils/symbol-manipulations
                make-keyword)
  (:import-from gefjon-utils/type-definitions
                optional)
  (:export define-class define-enum slots-list-to-make-instance-args))
(in-package gefjon-utils/define-class)

(defmacro err-uninit (slot-name)
  `(error "required field uninit: ~s" ',slot-name))

(defstruct slot-descriptor
  (private-name (err-uninit name) :type symbol)
  (type (err-uninit type))
  (may-init-unbound nil :type boolean)
  (initform (err-uninit initform))
  (initarg (err-uninit initarg) :type (optional keyword))
  (accessor (err-uninit accessor) :type symbol)
  (read-only nil :type boolean))

(defun parse-slot-descriptor (list)
  (destructuring-bind (public-name type &key may-init-unbound
                                          (private-name (symbolicate "%" public-name))
                                          (initform `(err-uninit ,public-name) initform-supplied-p)
                                          (initarg (make-keyword public-name))
                                          (accessor public-name)
                                          read-only)
      list
    (when (and may-init-unbound initform-supplied-p)
      (error "initform and may-init-unbound are mutually exclusive"))
    (when (and read-only (not accessor))
      (error ":READ-ONLY T is incompatible with :ACCESSOR NIL"))
    (make-slot-descriptor :private-name private-name
                          :type type
                          :may-init-unbound may-init-unbound
                          :initform initform
                          :initarg initarg
                          :accessor accessor
                          :read-only read-only)))

(defun output-slot-descriptor (slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFCLASS'"
  (with-slots (private-name type may-init-unbound initform initarg accessor read-only) slot-descriptor
    `(,private-name
      :type ,type
      ,@(unless may-init-unbound
          `(:initform ,initform))
      ,@(when initarg
          `(:initarg ,initarg))
      ,@(when accessor
          `(,(if read-only :reader :accessor) ,accessor)))))

(defun slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (symbolicate class-name '- slot-name '-boundp))
           (defboundp (slot-descriptor)
             (with-slots (name) slot-descriptor
               `(progn
                  (declaim (ftype (function (,class-name) boolean)
                                  ,(boundp-name name)))
                  (defun ,(boundp-name name) (instance)
                    (slot-boundp instance ',name))))))
    `(progn ,@(mapcar #'defboundp
                      (remove-if-not #'slot-descriptor-may-init-unbound slot-descriptors)))))

(defmacro define-class (class-name slot-descriptors &key (documentation "generated by `GEFJON-UTILS:DEFINE-CLASS'")
                                                  superclasses)
  "an altpernate syntax for `CL:DEFCLASS'.

arranges for a `PRINT-OBJECT' method which prints all the present
slots of the instance, including inherited slots.

each SLOT-DESCRIPTOR should be a list of the form
 (SLOT-NAME SLOT-TYPE &key MAY-INIT-UNBOUND INITFORM INITARG ACCESSOR
READ-ONLY). the new class will have a slot named SLOT-NAME with a
declared type of SLOT-TYPE.

if MAY-INIT-UNBOUND is `T', the slot will be
uninitialized until/unless set either by passing INITARG to
`MAKE-INSTANCE' or using (`SETF' ACCESSOR).

if INITFORM is supplied, its value will be the slot's default
initform, unless overridden by passing INITARG to
`MAKE-INSTANCE'. INITFORM and MAY-INIT-UNBOUUND are incompatible.

INITARG should be a keyword or `NIL'. it defaults to the name of the slot
converted to a keyword. if INITARG is supplied and NIL, there will be
no way to initialize the slot while calling `MAKE-INSTANCE'.

ACCESSOR should be a symbol. it defaults to a symbol that looks like
CLASS-NAME-SLOT-NAME interned in `*PACKAGE*'. if supplied and NIL, no
accessor will be defined.

if READ-ONLY is `T', a reader will be defined instead of an
accessor. the slot will still be writable with (`SETF'
`SLOT-VALUE'). READ-ONLY is incompatible with `:ACCESSOR' `NIL'"
  (let ((slot-descriptors (mapcar  #'parse-slot-descriptor slot-descriptors))
        (superclasses (append superclasses '(print-all-slots-mixin))))
    `(progn
       (defclass ,class-name ,superclasses
         ,(mapcar #'output-slot-descriptor slot-descriptors)
         (:documentation ,documentation))
       ,(slot-boundp-forms class-name
                           slot-descriptors))))

(defmacro define-enum (type-name common-slots variants &rest define-class-options)
  "define an enum or sum type named TYPE-NAME with COMMON-SLOTS.

this compiles into a superclass TYPE-NAME and a subtype for each of
the VARIANTS. it's likely incorrect to do (`MAKE-INSTANCE'
'TYPE-NAME), since TYPE-NAME is intended to be an abstract
superclass.

VARIANTS should be a list of variant-descriptors, each of which is a
list of the form (VARIANT-NAME UNIQUE-SLOTS).

UNIQUE-SLOTS is a list of slot-descriptors, each of which is a list of
the form (SLOT-NAME SLOT-TYPE `&KEY' INITFORM MAY-INIT-UNBOUND
ACCESSOR). the `&KEY' args all have sensible defaults."
  `(progn (define-class ,type-name ,common-slots ,@define-class-options)
          (extend-enum ,type-name ,variants)))

(defmacro extend-enum (enum-name variants)
  "add additional VARIANTS to an already-defined enum ENUM-NAME.

this just defines subclasses of ENUM-NAME."
  (flet ((define-variant (variant)
           (destructuring-bind (variant-name unique-slots
                                &rest options &key superclasses &allow-other-keys)
               variant
             `(define-class ,variant-name
                ,unique-slots
                ;; put declared superclasses before the enum class, to
                ;; allow mixins on variants which supersede methods
                ;; from the enum class.
                :superclasses (,@superclasses ,enum-name)
                ,@(remove-from-plist options :superclasses)))))
    `(progn
       ,@(mapcar #'define-variant variants))))

(defun slots-list-to-make-instance-args (slots)
  "For a list of slot descriptors like ((A TYPE-A) (B TYPE-B)), return a list (:A A :B B) which can be inserted into a `make-instance' form"
  (iter (for (slot-name) in slots)
    (collect (make-keyword slot-name))
    (collect slot-name)))
